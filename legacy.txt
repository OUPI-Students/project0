# Only one of these was necessary as they do the same thing
# Reads file file_name and returns contents in a list of usable 8-bit chunks
def read_binary_file_bits(file_name):
	chunks = []
	try:
		with open(file_name, 'rb') as file:
			byte = file.read(9)
			while byte:
				chunks.append(byte)
				byte = file.read(9)
	except FileNotFoundError:
		print(f"The file at {file_path} was not found.")
	except Exception as e:
		print(f"An error occurred: {e}")
	return chunks



	Prints contents of the file in 8-bit chunks
	bits = read_binary_file_bits(file_name)
	print("Contents of read file in 8-bit chunks: ")
	print(bits)
	
# Converting to hexidecimal not required
# Generates 3 sub keys
def key_scheduler(main_key):
	# Convert the key to a hexadecimal string with 3 characters
	key_hex = f"{main_key:03x}"
	print("key hex: ")
	print(key_hex)
	
	# Convert each character to its decimal value
	key_dec = [int(char, 16) for char in key_hex]
	print("key dec: ")
	print(key_dec)
	
	# Create the 3-round subkeys using bitwise XOR
	k1 = key_dec[0] ^ key_dec[1]
	k2 = key_dec[1] ^ key_dec[2]
	k3 = key_dec[2] ^ key_dec[0]
	return [k1, k2, k3]
	
# Save my brain, no key input today
# Reads user input and converts to binary
def text_to_binary(user_key):
	binary = ' '.join(format(ord(char), '08b') for char in user_key)
	return binary
	
	# 12-bit key 'ACF' = 101011001111
	# User inputs key
	print("Input encryption key: ")
	user_key = input()
	main_key = text_to_binary(user_key)
	print(f"\nMain Key: \n{main_key}")
	
